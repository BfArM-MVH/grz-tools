# Processing Submissions

## Setup and Environment

### Secrets Environment Variables

The following environment variables are used by the various commands in this SOP to load required secrets.
Please note the **double underscores** in some variable names; they are not typos.

- `C4GH_PASSPHRASE`
    - passphrase for Crypt4GH private key to decrypt inbox submissions
- S3 access credentials
    - `GRZ_S3__ACCESS_KEY`
    - `GRZ_S3__SECRET`
- BfArM API client ID and secret
    - `GRZ_PRUEFBERICHT__CLIENT_ID`
    - `GRZ_PRUEFBERICHT__CLIENT_SECRET`
- `GRZ_DB__AUTHOR__PRIVATE_KEY_PASSPHRASE`
    - Passphrase for SSH private key to sign DB updates for the author defined in the relevant configuration file (config.db.yaml), see below.

To define an environment variable without leaking it in your shell history, you can use:

``` bash
read -s ENV_VAR_NAME && export ENV_VAR_NAME
```

### Software Environment

Install the latest versions of `grzctl` and `grz-cli` from Bioconda.

If you need to run a development/unreleased version of grzctl, in case you need a fix or feature that is not released to PyPI or Bioconda yet, see [these instructions](index.md#running-a-development-version).

### Configuration Files

??? example "config.inbox.yaml"
    ``` yaml
    keys:
      grz_public_key_path: 'grz-inbox.pub'
      grz_private_key_path: 'grz-inbox.sec'

    identifiers:
      grz: 'GRZXXXYYY' # replace with GRZ ID
      le: '123456789'  # replace with the LE ID for the bucket

    pruefbericht:
      authorization_url: 'https://URL_TO_BFARM/token'
      api_base_url: 'https://URL_TO_BFARM/api'

    s3:
      endpoint_url: 'https://your-s3-endpoint'
      bucket: 'grz-inbox-12345'  # replace with your inbox bucket name
    ```

??? example "config.consented.yaml"
    ``` yaml
    keys:  
      grz_public_key_path: 'grz-consented.pub'

    s3:
      endpoint_url: 'https://your-s3-endpoint'
      bucket: 'grz-archive-consented'  # replace with your consented archival bucket name
    ```

??? example "config.nonconsented.yaml"
    ``` yaml
    keys:  
      grz_public_key_path: 'grz-nonconsented.pub'

    s3:
      endpoint_url: 'https://your-s3-endpoint'
      bucket: 'grz-archive-nonconsented'  # replace with your nonconsented archival bucket name
    ```

??? example "config.db.yaml"
    ``` yaml
    db:
      database_url: "sqlite:////absolute/path/to/submission.db.sqlite"
      author:
        name: "your-username-without-whitespace"
        private_key_path: "/path/to/usernames/private/ssh/key"
      known_public_keys: "/path/to/list/of/known_public_keys"  # one public key per line
    ```

A relative path to the submission database can be provided with only three slashses after sqlite, e.g. `sqlite:///relative/path/to/submission.db.sqlite`.

Each user of the database needs their own **Ed25519** SSH key as generated by `ssh-keygen`:

``` shell
ssh-keygen -t ed25519 -f steward-name.ssh -C your-username-without-whitespace
```

### Initialize submission database

This should never need to be done in normal production use since all databases are already initialized at existing GRZs.

``` shell
grzctl db --config-file config.db.yaml init
```

Note that any state update to the DB will require signing the transaction with the private key specified in the config and will therefore ask for the secret key's passphrase, if the passphrase is not set in the environment (see above for variable name).

## Identify and select a submission for processing

To list all submissions:

```
$ grzctl list --config-file ${INBOX_CONFIG}
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┓
┃ ID                            ┃ Status     ┃ Oldest Upload       ┃ Newest Upload       ┃
┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━┩
│ 123456789_2024-11-08_1ad7b9d8 │ Incomplete │ 2025-04-25 12:59:09 │ 2025-04-25 12:59:09 │
│ 123456789_2024-11-08_d0f805c5 │ Complete   │ 2025-05-06 07:08:58 │ 2025-05-06 07:09:00 │
└───────────────────────────────┴────────────┴─────────────────────┴─────────────────────┘
```

## Download a submission

!!! info "Recording errors"

    In case any of the later operations fail, make sure to update the submission's status to "Error":

    ``` shell
    grzctl db --config-file ${DB_CONFIG} submission update $submission_id error
    ```

Create a directory for incoming submissions:

``` shell
mkdir incoming/
```

Pick e.g., the oldest "Complete" submission:

``` shell
submission_id=$(grzctl list --config-file ${INBOX_CONFIG} --json | jq -r 'map(select(.state == "complete"))[0].submission_id')
```

Add this submission to the submission database:

```
grzctl db --config-file ${DB_CONFIG} submission add $submission_id
```

Update submission status to "Downloading"

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id downloading
```

To download the selected submission, issue:

``` shell
grzctl download --submission-id "$submission_id" --output-dir "incoming/${submission_id}" --config-file ${INBOX_CONFIG}
```

When finished, update submission status to "Downloaded"

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id downloaded
```

Now is also a good time to add reporting metadata of the submission to the database.
Also to check the true finalized upload date of the submission and add that to the database instead of the one provided in metadata.json, which can be incorrect.

``` shell
grzctl db --config-file ${DB_CONFIG} submission populate $submission_id "incoming/$submission_id/metadata/metadata.json"

# calculate the actual submission date (completely uploaded to inbox)
submission_date=$(
  grzctl --log-level WARNING list --config-file "${INBOX_CONFIG}" --json --limit 10000 \
    | jq -r 'map({(.submission_id): .newest_upload | sub("\\.[0-9]+"; "") | fromdateiso8601 | strftime("%Y-%m-%d")}) | reduce .[] as $item ({}; . * $item) | ."'"$submission_id"'"'
)

# set the limit to an absurdly high number so that all the submissions are captured. By default, this is restricted to 10.
grzctl db \
  --config-file "${DB_CONFIG}" \
  submission modify \
  "$submission_id" \
  submission_date \
  "$submission_date"
```

Although not required, now might be a good time to double-check the submission in the database to make sure everything was recorded so far:

``` shell
grzctl db --config-file ${DB_CONFIG} submission show $submission_id
```

## Decrypt a submission

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id decrypting
grzctl decrypt --config-file ${INBOX_CONFIG} --submission-dir "incoming/${submission_id}"
grzctl db --config-file ${DB_CONFIG} submission update $submission_id decrypted
```

## Validate a submission

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id validating
grzctl validate --config-file ${INBOX_CONFIG} --submission-dir "incoming/${submission_id}"
grzctl db --config-file ${DB_CONFIG} submission modify $submission_id basic_qc_passed yes
grzctl db --config-file ${DB_CONFIG} submission update $submission_id validated
```

## Check consent of submission

```
$ CONSENT=$(grzctl consent --submission-dir "incoming/${submission_id}")
$ echo $CONSENT
true
```

## Re-encrypt submission with appropriate keypair

Depending on consent, a different configuration file is needed, as these define the keys used for encryption.

``` shell
ARCHIVE_CONFIG=$(if [ "$CONSENT" = "true" ]; then echo "${CONSENTED_CONFIG}"; else echo "${NONCONSENTED_CONFIG}"; fi)
grzctl db --config-file ${DB_CONFIG} submission update $submission_id encrypting
```

Encrypt will output under the `encrypted_files/` directory in the submission root.
The inbox-encrypted files are already there, so you may either move them to a different path if you still want them (see below) or use the `--force` flag to `grzctl encrypt` to overwrite them.

``` shell
mv "incoming/${submission_id}/encrypted_files" "incoming/${submission_id}/encrypted_files_inbox"
grzctl encrypt --config-file ${ARCHIVE_CONFIG} --submission-dir "incoming/${submission_id}"
grzctl db --config-file ${DB_CONFIG} submission update $submission_id encrypted
```

## Archive submission into appropriate bucket

``` shell
tanG=$(jq --raw-output '.submission.tanG' "incoming/${submission_id}/metadata/metadata.json")
rg --files-with-matches $tanG "incoming/${submission_id}/logs" | xargs sed -i "s/$tanG/REDACTED_TAN_G/" || [ $? -eq 123 ]
localCaseId=$(jq --raw-output '.submission.localCaseId' "incoming/${submission_id}/metadata/metadata.json")
rg --files-with-matches $localCaseId "incoming/${submission_id}/logs" | xargs sed -i "s/$localCaseId/REDACTED_LOCAL_CASE_ID/" || [ $? -eq 123 ]
grzctl db --config-file ${DB_CONFIG} submission update $submission_id archiving
grzctl archive --config-file ${ARCHIVE_CONFIG} --submission-dir "incoming/${submission_id}"
grzctl db --config-file ${DB_CONFIG} submission update $submission_id archived
```

## Submit Prüfbericht to BfArM

The following command will extract the necessary information for the Prüfbericht directly from the submission metadata.
First, the non-redacted metadata must be restored so the Prüfbericht command can read the real tanG.

``` shell
mv "incoming/${submission_id}/metadata/metadata.json" "incoming/${submission_id}/metadata/metadata.redacted.json"
cp "incoming/${submission_id}/metadata/metadata.orig.json" "incoming/${submission_id}/metadata/metadata.json"
grzctl pruefbericht generate from-submission-dir "incoming/${submission_id}" > "incoming/${submission_id}.pruefbericht.json"
grzctl pruefbericht submit --config-file "${INBOX_CONFIG}" --pruefbericht-file "incoming/${submission_id}.pruefbericht.json"
rm "incoming/${submission_id}.pruefbericht.json"
```

You can also generate the Prüfbericht from just the metadata JSON:

``` shell
grzctl pruefbericht generate from-metadata "incoming/${submission_id}/metadata/metadata.json" > "incoming/${submission_id}.pruefbericht.json"
```

You can also output the Prüfbericht to a file for archival, as long as the tanG is redacted since it cannot be kept long-term after phase 0.
An example of outputting the Prüfbericht with a redacted tan is below.
The output could be redirected into a file.

``` shell title="Command"
grzctl pruefbericht generate from-submission-dir "incoming/${submission_id}" | jq 'setpath(["SubmittedCase", "tan"]; "<REDACTED>")' | tee "incoming/${submission_id}/logs/pruefbericht.json"
```

``` json title="Output"
{
  "SubmittedCase": {
    "submissionDate": "2024-11-08",
    "submissionType": "initial",
    "tan": "<REDACTED>",
    "submitterId": "123456789",
    "dataNodeId": "GRZM00123",
    "diseaseType": "oncological",
    "dataCategory": "genomic",
    "libraryType": "panel",
    "coverageType": "GKV",
    "dataQualityCheckPassed": true
  }
}
```

Finally, record that we reported this submission:

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id reported
```

## Perform detailed quality control (QC) on selected submissions

Install Nextflow 25.04+ to run the QC pipeline.
Use `-profile conda`, `-profile docker`, or `-profile singularity` depending on your environment.
Creating and providing a custom `grz.nextflow.config` is optional.

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id qcing
mkdir "incoming/${submission_id}/qc"
git clone https://github.com/BfArM-MVH/GRZ_QC_Workflow
cd GRZ_QC_Workflow
git checkout v1.0.0
cd ..
conda create -n grzqc -c conda-forge -c bioconda 'nextflow=25.04,>=25.04.3'
conda activate grzqc
nextflow -c grz.nextflow.config run GRZ_QC_Workflow/ -profile conda --reference_path qc-references/ --submission_basepath "incoming/${submission_id}" -work-dir "incoming/${submission_id}/qc/work" --outdir "incoming/${submission_id}/qc/out"
index_detailed_qc_status=$(awk -F, '$2 == "index"' < "incoming/${submission_id}/qc/out/report.csv" | python -c 'import csv,sys; print("\n".join(row[6] for row in csv.reader(sys.stdin)))' | sort | uniq)
grzctl db --config-file ${DB_CONFIG} submission modify $submission_id detailed_qc_passed $(if [ $index_detailed_qc_status == 'PASS' ]; then echo 'yes'; else echo 'no'; fi)
grzctl db --config-file ${DB_CONFIG} submission populate-qc "$submission_id" "incoming/${submission_id}/qc/out/report.csv"
grzctl db --config-file ${DB_CONFIG} submission update $submission_id qced
```

## Clean submission from inbox

``` shell
grzctl db --config-file ${DB_CONFIG} submission update $submission_id cleaning
grzctl clean --config-file ${INBOX_CONFIG} --submission-id "${submission_id}"
rm -rf "incoming/${submission_id}"
grzctl db --config-file ${DB_CONFIG} submission update $submission_id cleaned
```

